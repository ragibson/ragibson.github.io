[{"content":"After playing around with QR code corruptions in \u0026ldquo;Tips on Creating the Smallest Possible QR Codes\u0026rdquo;, I became curious about generating a few animated variants that are valid on every frame.\nThe perfect algorithm candidates for this are simple cellular automata, which are models of computation on a grid that repeatedly update the state of each cell based on the arrangement of its neighbors. For instance, a cell might \u0026ldquo;live\u0026rdquo; or \u0026ldquo;die\u0026rdquo; depending on the state of its nearby cells.\nOn top of this, I also allowed a few caveats for more interesting patterns and ease of generation.\nI ran the automata on a grid nine times finer than the modules of a standard QR code I threw in short periods of noisier updates where the automata\u0026rsquo;s rules were loosened, yielding behavior akin to a Monte Carlo simulated anneal I evaluated the automata\u0026rsquo;s update rules in a random order rather than simultaneously In later passes, I allowed updates to be completely rejected if they created an invalid QR code, effectively altering the random sampling order of cell updates Here, we\u0026rsquo;ll start with a very simple method and then progressively add in enhancements and discuss the issues I ran into along the way.\nThe simple, fixed centers method # The Python package \u0026ldquo;segno\u0026rdquo; offers a somewhat standard method to generate QR codes that incorporate colorful images or GIFs. Their solution is to fix all the position, tracking, and timing modules as well as the center portion of every other module. Such a restriction is shown below.\nA QR code and a visualization of the regions unaffected by this simple strategy (colored in red). The idea here is that most QR code readers sample from the estimated center of each module, so that portion is really all that is needed for readability as long the position and orientation of the code can be accurately determined.\nThe resulting codes are typically valid, although there are cases with complex patterns that might confuse smartphone readers. Despite this, they can generally be scanned with some effort, including the ones below which are maximally filled with white and black.\nThe resulting QR codes after coloring in all allowed pixels with white and black, respectively. Running a few simple automata under these constraints indeed results in valid QR codes. The patterns are also pretty interesting to look at, especially since the fixed regions influence neighboring pixels through the same update rules as the rest of the grid.\nTo me, two particular columns stand out: the right-most one, which essentially dithers the QR code, and the second one, which creates smooth, gyrating blobs.\nAn aside about halting update rules # The examples presented here do not reach a final halting state and continue indefinitely. However, you can create compelling patterns using update rules that do lead to a final, static state.\nFor example, I accidentally stumbled upon one that, in the limit, was equivalent to copying states diagonally down and to the right whenever possible. Despite being mostly uninteresting from an animation perspective, I am quite happy with how these turned out and their relative robustness when scanning.\nGenerated QR codes from a halting update rule that creates diagonal stripes across the data modules. Removing pixel restrictions by explicitly testing for QR code validity # While segno\u0026rsquo;s strategy is effective, it is also pretty heavy-handed. If you\u0026rsquo;ve ever seen artistic QR codes in shops or online, it\u0026rsquo;s apparent that you don\u0026rsquo;t actually need to keep the tracking modules fixed. Moreover, the built-in error correction should allow us to completely alter some of the modules without compromising readability.\nAs such, we could simply try testing the validity of the QR code on each modification. If it ever becomes invalid, we\u0026rsquo;ll just reject the update and try again.\nHowever, if you try this you\u0026rsquo;ll quickly run into the issue that automated QR code readers are way too lenient!1 Below, I\u0026rsquo;ve included three QR codes that are barely recognizable, but still technically valid according to some of the most popular Python decoders.\nThree absurdly corrupted QR codes that both pyzbar and OpenCV can detect and decode \u0026ldquo;correctly\u0026rdquo;. Ultimately, randomized updates will exploit every little idiosyncrasy of these decoding algorithms, yielding QR codes that are entirely unreadable in real-world situations.\nOn top of this, smartphone manufacturers like Apple, Google, and Samsung use proprietary and opaque decoding implementations in their devices. It seems extremely difficult in general to determine what they will be able to read and which patterns will confuse them. Their variety of lenses, auto-focus, auto-exposure, and other post-processing techniques only further complicate the matter.\nImproving QR code readability with robustness filters # To overcome these challenges, we need to enhance the QR codes to be more robust than strictly necessary.\nOne effective technique I settled on was ensuring that the QR code remains valid after running a set of image filters. Rank filters that dilate and erode the image proved to be particularly effective for this purpose, a few of which are visualized below.\nA QR code (top-left corner) and the result of running five different 3x3 and 5x5 rank filters on it. This intuitively makes sense as it prevents the readers from placing too much emphasis on small regions of the code. Indeed, since we\u0026rsquo;re reading directly from a lossless, undistorted image, the readers are free to just look at the center-most pixel in each module, which requires far more accuracy than we are likely to get in practice.\nI also took the liberty of fixing the inner portions of the format information in the upper left and the tracking modules to prevent them from being completely obliterated by the automata\u0026rsquo;s random updates. This adjustment significantly improved the overall detection and readability on smartphones.\nThis looser restriction is visualized below, and you should note how much less of the total QR code is off-limits to the automata compared to the initial method.\nA QR code and a visualization of the regions unaffected by this newer strategy (colored in red). Importantly, this technique allows for entire modules to be corrupted, provided that the error correction can restore the original data. Moreover, the tracking modules can be corrupted slightly, which provides a more artistic bent to overall QR code.\nRunning the automata now gives us the examples below, and I was able to successfully scan them all with an iPhone, Google Lens, Samsung\u0026rsquo;s camera, and others.\nHowever, it\u0026rsquo;s important to note that this method effectively creates a few fixed areas of 5x5 pixels to overcome the filters. This is larger than the fixed regions of the simpler method. Unfortunately, a set of 3x3 filters did not create codes that were robust enough for my liking.\nI also explored blurring filters, rotations, and various resizing algorithms, but they didn\u0026rsquo;t prove as effective as rank filters. Similarly, obscuring regions (i.e., repeatedly cutting out various parts of the image to increase redundancy and prevent dependence on specific modules) did not increase robustness as much as I would have hoped.\nUltimately, I think this could be greatly improved upon, particularly with more insight into common QR code reader implementations and more realistic distortions. That said, I am relatively happy with the result as it stands now, especially since I have already spent thousands of compute hours thus far in my experiments.\nSee also and references # The earlier post about \u0026ldquo;Tips on Creating the Smallest Possible QR Codes\u0026rdquo; and the relevant links therein. The Wikipedia articles on cellular automata and simulated annealing. This is clearly intentional in order to improve their decoding robustness, but it is detrimental for our purposes.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"17 October 2023","permalink":"/posts/qr-code-automata/","section":"Posts","summary":"An experiment in using randomized cellular automata to generate QR codes that remain valid on every frame.","title":"Animated Cellular Automaton QR Codes"},{"content":"","date":"17 October 2023","permalink":"/tags/cellular-automata/","section":"Tags","summary":"","title":"cellular-automata"},{"content":"","date":"17 October 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"17 October 2023","permalink":"/tags/qr-codes/","section":"Tags","summary":"","title":"qr-codes"},{"content":"","date":"17 October 2023","permalink":"/","section":"Ryan A. Gibson","summary":"","title":"Ryan A. Gibson"},{"content":"","date":"17 October 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"17 October 2023","permalink":"/tags/video/","section":"Tags","summary":"","title":"video"},{"content":"","date":"13 September 2023","permalink":"/tags/investing/","section":"Tags","summary":"","title":"investing"},{"content":"","date":"13 September 2023","permalink":"/tags/retirement/","section":"Tags","summary":"","title":"retirement"},{"content":" Many Americans underestimate the importance of early retirement savings, often assuming they can delay saving until later in their careers.\nOn the contrary, a 22-year-old college graduate that saves $300/month will have more in retirement than a worker who starts saving $1,100/month at 40 years old.\nAs such, if you are financially stable, it is best and easiest to start saving early!1\nIn this article, we\u0026rsquo;ll explore the significance of saving for retirement in your early working years by focusing on the power of compound growth alone. However, you should keep in mind such savings generally decrease your income taxes, are partially matched by your employer, improve your budgeting capabilities, and provide several other benefits. I think we can all agree that financial security and peace of mind in retirement go a long way to relieving stress in our daily lives.\nComparing different retirement saving strategies # Consider three people who start investing at different times but all retire at 70 years old.\nA high school graduate who consistently saves $375/month from age 18 and continues through their adulthood. This is 15% of a $15/hour paycheck. A coworker who starts saving $700/month at age 30. Their manager who waits and tries to catch up by saving $1,450/month at age 40. Perhaps surprisingly, the early-saving high school student comes out on top. They end up with ~$2.2 million in today\u0026rsquo;s dollars after investing $234k in total.\nOn the other hand, the coworker and manager both end up with ~$1.7 million after investing $336k and $522k, respectively.\nClearly, #1 is the best option here. The high-school student invested the least amount, has the most money in retirement, and didn\u0026rsquo;t have to experience huge, sudden losses of disposable income in the middle of their working career. Starting early with small contributions can yield greater savings than starting later with much larger ones!\nNow, let\u0026rsquo;s visualize some of these fundamental benefits of saving early.\nSaving early is easier # As the saying goes, \u0026ldquo;the best time to start investing was 20 years ago and the second-best time is now.\u0026rdquo;\nIf you plot out the amount you need to save each month for a fixed nest egg at retirement, you find that it becomes exponentially harder the more you wait.\nMonthly savings required to reach $1 million at age 67, based on the age you start investing. Saving longer makes you exponentially more money # Investments grow significantly over time, thanks to the power of exponential compound growth. However, the degree to which this effect snowballs may be unintuitive if you have not worked with it before.\nRemember, the longer your money stays invested, the more it can grow.\nAverage earnings of each invested dollar as the investing time horizon grows longer. Your first years have the biggest impact # Compound growth makes the first years of contributions the most influential. They will always have the longest time to multiply, relative to the rest of the portfolio.\nPercentage of total savings attributed to initial investment years over time. The underlying calculations # To better understand how your choices matter, let\u0026rsquo;s break down the math behind these savings scenarios. You can freely skip this section if you are not interested.\nWe assume that these individuals continuously save a set amount each year, and their investments grow at an annualized rate of 7%. This is around the historical average return of the U.S. stock market over the last century after accounting for inflation.\nThen, with annual savings of \\( s \\) dollars, a time horizon of \\( T \\) years, and an annual growth rate of \\( r \\), you arrive at a final portfolio value of $$ s \\cdot \\int_0^T r^t \\text{ d}t = s \\cdot \\frac{r^T - 1}{\\ln(r)} $$\nIf you\u0026rsquo;re curious about the continuous investment assumption, it is basically equivalent to the more lengthy, discrete calculation of monthly contributions. For example, $$ (\\text{\\$6000 saved annually}) \\cdot \\frac{1.07^{\\text{(45 years)}} - 1}{\\ln(1.07)} \\approx \\text{\\$1,773,827} $$ is quite close to the sum of monthly contributions over the same period, $$ \\sum_{t=0}^{\\text{(45 years)} \\cdot 12 - 1} \\left[ (\\text{\\$500 saved monthly}) \\cdot 1.07^{t/12} \\right] \\approx \\text{\\$1,768,831} $$\nSee also and references # Compound growth favors those who start saving early, so I highly recommend starting as soon as you are able. The following resources are a decent place to start:\nThe /r/personalfinance wiki pages on budgeting, building an emergency fund, and saving for retirement or other goals. These provide overall advice and planning options regardless of what your financial picture currently looks like. For more in-depth information, see the Bogleheads wiki in general, including their general getting started pages and advice on creating simple three-fund investment portfolios or other lazy portfolios. These are more focused on individuals who are already investing, but do provide some guidance on achieving a sound financial footing for other readers. Needless to say, I am not a financial advisor and this should not be construed as financial advice. The content provided here is based on general knowledge and research. Please perform your own research and consult with a qualified financial professional as needed before making any significant financial decisions.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"13 September 2023","permalink":"/posts/early-savings-importance/","section":"Posts","summary":"A 22-year-old college graduate that saves $300/month will have more in retirement than a worker who starts saving $1,100/month at 40 years old. Let\u0026rsquo;s talk about it.","title":"The Importance of Saving Early for Retirement"},{"content":" Let\u0026rsquo;s face it, a good password never needs to be longer than 20-40 characters.\nAs of 2023, even a 15-character password is beyond the brute-force abilities of the entire human race.\nHere, we\u0026rsquo;ll start with the fundamentals of measuring password strength, and then demonstrate the range of hackable password lengths \u0026ndash; from solo hackers to entire nations, all the way up to a galactic superpower.\nCaveats abound # This discussion mainly applies to randomly generated passwords with a large character set1 since memorable passwords are generally quite insecure. Predictable patterns are simply easy to guess.\nFor example, an English word in a password contributes ~16 bits of entropy (a measure of information or password strength), equivalent to 2-3 ASCII characters.\nIf your password looks anything like PronounceCoauthor1984!, it\u0026rsquo;s about as secure as k^D5] and can be broken pretty quickly.2 And that\u0026rsquo;s a lot better than most passwords I see.\nIndeed, in my experience, a frightening number of users\u0026rsquo; passwords can be broken in seconds on a consumer-grade desktop. Such attacks typically start with massive lists of popular passwords from prior leaks and common words in many languages. Then, they add special characters, tweak capitalization, and make other modifications as needed.\nThe concept of security level # Cryptographic security is like building a lock that only the right key can open. The strength of the lock depends on how many different keys an attacker would have to try to break in.\nRoughly speaking, if a cryptographic scheme has \u0026ldquo;128-bit security\u0026rdquo;, then an attacker would need to perform \\( 2^{128} \u0026gt; 3 \\cdot 10^{38} \\) operations to decrypt it. That\u0026rsquo;s 300 trillion trillion trillion.\nMany HTTPS connections provide precisely this level of security for the communication channel, even for some large U.S. banking websites.3 The data sent over those connections can be very sensitive and those companies apparently believe 128 bits is sufficient to protect it.\nThere are 95 characters in the printable ASCII set, so any password over \\( \\log_{95}(2^{128}) = 128 / \\log_2(95) \u0026lt; 20 \\) characters is completely useless in this context. At that point, the cryptographic methods used to secure the data become the weakest link, and it is simply easier to break the encryption primitive than attack the password itself.\nThe most secure common encryption methods provide 256 bits of security, which is exponentially more secure.4 In other words, breaking a 256-bit scheme is as challenging as breaking 300 trillion trillion trillion 128-bit ones.\nThe limits of a typical online attack # Now, lets look at the limits of what a practical attack could look like.\nAn online service should have rate limiting so you can\u0026rsquo;t try a hundred passwords all at once, but let\u0026rsquo;s say that the implementation is poor or there is an unknown exploit allowing you to check password validity as often as the network allows.\nAssuming one guess per millisecond over an entire year, you can break ~35 bits of security. $$ \\left(1 \\text{ kHz}\\right) \\cdot \\left(1 \\text{ year}\\right) \\approx 2^{34.9} \\approx 3.2 \\cdot 10^{10} $$\nThat is less than the entropy of keV#]i, a 6-character password.\nHowever, the real concern is in an offline attack where someone has gained access to a database leak or exfiltrated data from the servers themselves. In those cases, you can easily test passwords with all the computational power you have on hand and never have to worry about network delays.\nThe limits of practical offline attacks # For simplicity and conservativeness, we\u0026rsquo;re going to assume that a key can be checked in a password hash or encryption scheme in a single floating point operation. This is pretty unrealistic, but perhaps the attacker has procured specialized ASICs specifically to attack you or a service that you use.\nA lone hacker # As a baseline, you can get up to ~7 TFLOPS of FP32 performance per $100 through an Arc A750, RX 7900 XTX, or RTX 4060 Ti.\nLet\u0026rsquo;s say a lone hacker has $10k to throw around and salvages the rest of their rigs for free from tech recycling or theft. They also siphon free electricity directly from the grid or an unsuspecting industrial company. In our idealized scenario, this yields a guess rate of 700 THz.\nOver 1 year, they can break ~74 bits of security. $$ \\left(700 \\text{ THz}\\right) \\cdot \\left(1 \\text{ year}\\right) \\approx 2^{74.2} \\approx 2.2 \\cdot 10^{22} $$\nFor reference, that\u0026rsquo;s under the entropy of iDif2$isXM\u0026amp;:, a 12-character password.\nRealistically, common attacks just run through every credential in a leak and exploit the users with the weakest passwords. If a hacker is willing to spend a year cracking yours in particular, you are probably a high profile individual and have much bigger issues to worry about.\nA state actor # Since 2018, multiple supercomputers and public distributed systems have achieved performance above 1 exaFLOPS (1 million TFLOPS). It is reasonable to suspect this is within the abilities of the major superpowers of the world, especially through botnets and classified supercomputers. In fact, the U.S. was planning such systems as far back as 2007-2008.\nAs of June 2023, the United States has at least 3.5 EFLOPS of (non-distributed) supercomputing power.5\nOver 1 year, this would break ~87 bits of security. $$ \\left(3.5 \\text{ EHz}\\right) \\cdot \\left(1 \\text{ year}\\right) \\approx 2^{86.5} \\approx 1.1 \\cdot 10^{26} $$\nThis could break y1V\u0026quot;5)C{Kqam=, a 13-character password, but nothing more.\nHuge distributed systems can be more powerful, but are unlikely to be controlled by a single entity. That said, people have managed to run requests on AWS that would have ranked as one of the most powerful supercomputers in the world.6\nThe global computing power # It is difficult to estimate the total computing power of the human race, but it is likely below 10 zettaFLOPs (i.e., 1 thousand ExaFLOPS).7 For comparison, the hash rate of the entire Bitcoin network is currently ~500 EHz.\nOver 1 year, this would break ~98 bits of security. $$ \\left(10 \\text{ ZHz}\\right) \\cdot \\left(1 \\text{ year}\\right) \\approx 2^{98.0} \\approx 3.2 \\cdot 10^{29} $$\nThis could almost break +-5{;C:pPf?JcPy, a 15-character password with ~98.5 bits of entropy.8\nThe limits of physics # There is a sci-fi concept called a Matrioshka brain, which is a massive structure that would consume the entire energy output of a star to power a supercomputer of unbelievable strength.\nWith the power output of our Sun, operating at the theoretical limit of energy consumption and the theoretical limit of thermodynamic efficiency, you can achieve \\({\\approx}1.45 \\cdot 10^{49}\\) Hz of processing power.9 Scaling up to the luminosity of the entire Milky Way galaxy yields \\({\\approx} 3 \\cdot 10^{60}\\) Hz of processing power.\nAn illustration of a Matrioshka brain, all devoted to cracking a single password. Over 1 year, the Sun\u0026rsquo;s brain breaks ~188 bits of security, $$ \\left(1.45 \\cdot 10^{49} \\text{ Hz}\\right) \\cdot \\left(1 \\text{ year}\\right) \\approx 2^{188.2} \\approx 4.6 \\cdot 10^{56} $$ and the Milky Way\u0026rsquo;s brain breaks ~226 bits of security. $$ \\left(3 \\cdot 10^{60} \\text{ Hz}\\right) \\cdot \\left(1 \\text{ year}\\right) \\approx 2^{225.8} \\approx 9.5 \\cdot 10^{67} $$ Over the entire age of the universe, the Milky Way\u0026rsquo;s brain breaks ~260 bits of security. $$ \\left(3 \\cdot 10^{60} \\text{ Hz}\\right) \\cdot \\left(13.8 \\text{ billion years}\\right) \\approx 2^{259.5} \\approx 1.3 \\cdot 10^{78} $$\nEssentially,\nAnnually, the sun can break [2\\p2%i@KabWM4hr\u0026amp;*m|!aok%S.o, a 28-character password with ~184 bits of entropy. Annually, the Milky Way can break KHH|j}\u0026lt;$\u0026gt;o8CnCg^Hc8s#I:',JzW3h^%d$, a 34-character password with ~223 bits of entropy. Over the age of the universe, the Milky Way can break C]Y9.1V+dYrA2[3rl?ZF1K9n=re~hUAVh+BJk|P, a 39-character password with ~256 bits of entropy. Notably, the final calculation that spans the age of our universe at the current luminosity of the entire galaxy barely exceeds 256 bits of security. Under these calculations, humanity will never break such a scheme by sheer brute force.\nIf someone tries to give you a password or API key longer than that, you can explain to them that it is absolutely unnecessary unless they\u0026rsquo;re trying to protect their secrets from an all-powerful God.\nSee also and references # The various links strewn across the footnotes of this post. The extra details in \u0026ldquo;Table of Password Lengths for Various Character Sets and Entropies\u0026rdquo;. The general Wikipedia articles on password strength, security level, and key size. I\u0026rsquo;ll be considering the character set to be the 95 printable ASCII characters, though many services place character restrictions which would decrease the number of possibilities accordingly. Recommendations using other character sets are shown in \u0026ldquo;Table of Password Lengths for Various Character Sets and Entropies\u0026rdquo;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThese words are from a small Diceware word list (7776 possibilities) provided by the EFF here. If you assume that most people select years from the last 5 decades and tend to only use the 12 main special characters !@#$%^\u0026amp;*-_.?, you find that this password has \\(\\log_2(7776^2 \\cdot 50 \\cdot 12) \\approx 35\\) bits of entropy. The capitalization here does not significantly increase the security of the password.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIt\u0026rsquo;s important to note that while the security level might be 128 bits, the actual key lengths may be longer! RSA and ECC keys actually need to be 3072 bits and 256-383 bits long, respectively, to achieve this security level. For more information, see page 55 of NIST Special Publication 800-57 Part 1 Rev. 5.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWe may see this change in the next few years as NIST\u0026rsquo;s Post-Quantum Cryptography Standards are finalized. Notably, the quantum Grover\u0026rsquo;s algorithm halves the security level of most symmetric-key algorithms. That said, 256-bit classical / 128-bit quantum security is still considered secure since that search space is considerably beyond current computational capabilities.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis is according to the statistics from the TOP500 list https://www.top500.org/statistics/list/.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFor example, an experiment in 2021 reached position 40 on the TOP500 list with \u0026ldquo;4,096 EC2 instances [\u0026hellip;] with a total of 172,692 cores\u0026rdquo;, achieving a performance of ~10 PFLOPS.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIt\u0026rsquo;s unclear how reputable this estimate is, but an AI Impacts wiki post claims a total of ~4 ZFLOPS as of Q1 2023. This is pretty consistent with my apparent 2019 estimate of ~1-2 ZHz in one of my favorite footnotes I\u0026rsquo;ve ever written (see page 13 of my undergraduate thesis).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRemember that bits of security are an exponential measure. That last 0.5 bits of security increase the time required from ~1 year to ~1.5 years.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis calculation is due to Arthur Isaac in Matrioshka Brains: Star-Powered Computers and closely matches that of the Computer performance by orders of magnitude Wikipedia article.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"20 August 2023","permalink":"/posts/absurd-password-lengths/","section":"Posts","summary":"A discussion of password strength, brute-force attacks, and the physical limits of the universe.","title":"Absurd Password Lengths and the Computational Limits of Humanity"},{"content":"","date":"20 August 2023","permalink":"/tags/cybersecurity/","section":"Tags","summary":"","title":"cybersecurity"},{"content":"","date":"20 August 2023","permalink":"/tags/passwords/","section":"Tags","summary":"","title":"passwords"},{"content":"","date":"20 August 2023","permalink":"/tags/extra/","section":"Tags","summary":"","title":"extra"},{"content":"","date":"20 August 2023","permalink":"/extra/","section":"Extra","summary":"","title":"Extra"},{"content":"This is an extra post to accompany \u0026ldquo;Absurd Password Lengths and the Computational Limits of Humanity\u0026rdquo;, which focused on passwords that use the full printable ASCII set. The equivalent recommendations for other character sets are as follows.\nRecall that these bit levels are from the limits computed in the main post for an attack over one year.\n35 bits \u0026ndash; A typical online attack 74 bits \u0026ndash; A lone hacker 87 bits \u0026ndash; A state actor 98 bits \u0026ndash; The global computing power 128 bits \u0026ndash; The maximum security provided by many common encryption methods 188 bits \u0026ndash; An ideal Matrioshka brain using the Sun 226 bits \u0026ndash; An ideal Matrioshka brain using the entire Milky Way 256 bits \u0026ndash; The security of the most secure common encryption methods For example, you need 25 random alphanumeric characters to reach 128 bits of entropy.\nCharacter set 35 bits 74 bits 87 bits 98 bits 128 bits 188 bits 226 bits 256 bits Digits 0-9 11 23 27 30 39 57 69 78 Hexadecimal 0-9A-F 8 17 20 22 29 43 51 58 Alpha a-z 8 16 19 21 28 40 49 55 Alphanumeric a-z0-9 7 15 17 19 25 37 44 50 Case-sensitive Alpha a-zA-Z 7 13 16 18 23 33 40 45 Case-sensitive Alphanumeric a-zA-Z0-9 6 13 15 17 22 32 38 43 Case-sensitive Alphanumeric and Basic Symbols a-zA-Z0-9!@#$%^\u0026amp;*-_.? 6 12 15 16 21 31 37 42 Printable ASCII (without space) 6 12 14 15 20 29 35 40 Printable ASCII 6 12 14 15 20 29 35 39 ","date":"20 August 2023","permalink":"/extra/password-entropies-and-character-sets/","section":"Extra","summary":"A reference for password length recommendations for various character sets and entropy levels.","title":"Table of Password Lengths for Various Character Sets and Entropies"},{"content":"This is an extra post to accompany \u0026ldquo;Tips on Creating the Smallest Possible QR Codes\u0026rdquo; and just contains complete tables of standard QR code data capacities in the numeric, alphanumeric, and binary/byte input modes.\nThe binary/byte input mode is the most general and can encode arbitrary data. The alphanumeric input mode can only encode 0–9, (uppercase) A–Z, space, and $%*+-./:. The numeric input mode can only encode the digits 0-9. Here are the total character limits, with more details available in the following sections.\nEncoding Preference Binary/Byte Alphanumeric Numeric Optimizing for size first 2953 4296 7089 At least M (medium), ~15% error correction 2331 3391 5596 At least Q (quartile), ~25% error correction 1663 2420 3993 Always H (high), ~30% error correction 1273 1852 3057 Optimizing for size first # Note that when preferring small sizes, only low error correction is optimal beyond version 5. At that point, it is always better to drop down to a smaller version if you had a higher error correction level.\nVersion-Error Correction Binary/Byte Alphanumeric Numeric 1-H 1 - 7 1 - 10 1 - 17 1-Q 8 - 11 11 - 16 18 - 27 1-M 12 - 14 17 - 20 28 - 34 1-L 15 - 17 21 - 25 35 - 41 2-Q 18 - 20 26 - 29 42 - 48 2-M 21 - 26 30 - 38 49 - 63 2-L 27 - 32 39 - 47 64 - 77 3-M 33 - 42 48 - 61 78 - 101 3-L 43 - 53 62 - 77 102 - 127 4-M 54 - 62 78 - 90 128 - 149 4-L 63 - 78 91 - 114 150 - 187 5-M 79 - 84 115 - 122 188 - 202 5-L 85 - 106 123 - 154 203 - 255 6-L 107 - 134 155 - 195 256 - 322 7-L 135 - 154 196 - 224 323 - 370 8-L 155 - 192 225 - 279 371 - 461 9-L 193 - 230 280 - 335 462 - 552 10-L 231 - 271 336 - 395 553 - 652 11-L 272 - 321 396 - 468 653 - 772 12-L 322 - 367 469 - 535 773 - 883 13-L 368 - 425 536 - 619 884 - 1022 14-L 426 - 458 620 - 667 1023 - 1101 15-L 459 - 520 668 - 758 1102 - 1250 16-L 521 - 586 759 - 854 1251 - 1408 17-L 587 - 644 855 - 938 1409 - 1548 18-L 645 - 718 939 - 1046 1549 - 1725 19-L 719 - 792 1047 - 1153 1726 - 1903 20-L 793 - 858 1154 - 1249 1904 - 2061 21-L 859 - 929 1250 - 1352 2062 - 2232 22-L 930 - 1003 1353 - 1460 2233 - 2409 23-L 1004 - 1091 1461 - 1588 2410 - 2620 24-L 1092 - 1171 1589 - 1704 2621 - 2812 25-L 1172 - 1273 1705 - 1853 2813 - 3057 26-L 1274 - 1367 1854 - 1990 3058 - 3283 27-L 1368 - 1465 1991 - 2132 3284 - 3517 28-L 1466 - 1528 2133 - 2223 3518 - 3669 29-L 1529 - 1628 2224 - 2369 3670 - 3909 30-L 1629 - 1732 2370 - 2520 3910 - 4158 31-L 1733 - 1840 2521 - 2677 4159 - 4417 32-L 1841 - 1952 2678 - 2840 4418 - 4686 33-L 1953 - 2068 2841 - 3009 4687 - 4965 34-L 2069 - 2188 3010 - 3183 4966 - 5253 35-L 2189 - 2303 3184 - 3351 5254 - 5529 36-L 2304 - 2431 3352 - 3537 5530 - 5836 37-L 2432 - 2563 3538 - 3729 5837 - 6153 38-L 2564 - 2699 3730 - 3927 6154 - 6479 39-L 2700 - 2809 3928 - 4087 6480 - 6743 40-L 2810 - 2953 4088 - 4296 6744 - 7089 At least M (medium), ~15% error correction # Note that only medium error correction is optimal beyond version 4.\nVersion-Error Correction Binary/Byte Alphanumeric Numeric 1-H 1 - 7 1 - 10 1 - 17 1-Q 8 - 11 11 - 16 18 - 27 1-M 12 - 14 17 - 20 28 - 34 2-Q 15 - 20 21 - 29 35 - 48 2-M 21 - 26 30 - 38 49 - 63 3-Q 27 - 32 39 - 47 64 - 77 3-M 33 - 42 48 - 61 78 - 101 4-Q 43 - 46 62 - 67 102 - 111 4-M 47 - 62 68 - 90 112 - 149 5-M 63 - 84 91 - 122 150 - 202 6-M 85 - 106 123 - 154 203 - 255 7-M 107 - 122 155 - 178 256 - 293 8-M 123 - 152 179 - 221 294 - 365 9-M 153 - 180 222 - 262 366 - 432 10-M 181 - 213 263 - 311 433 - 513 11-M 214 - 251 312 - 366 514 - 604 12-M 252 - 287 367 - 419 605 - 691 13-M 288 - 331 420 - 483 692 - 796 14-M 332 - 362 484 - 528 797 - 871 15-M 363 - 412 529 - 600 872 - 991 16-M 413 - 450 601 - 656 992 - 1082 17-M 451 - 504 657 - 734 1083 - 1212 18-M 505 - 560 735 - 816 1213 - 1346 19-M 561 - 624 817 - 909 1347 - 1500 20-M 625 - 666 910 - 970 1501 - 1600 21-M 667 - 711 971 - 1035 1601 - 1708 22-M 712 - 779 1036 - 1134 1709 - 1872 23-M 780 - 857 1135 - 1248 1873 - 2059 24-M 858 - 911 1249 - 1326 2060 - 2188 25-M 912 - 997 1327 - 1451 2189 - 2395 26-M 998 - 1059 1452 - 1542 2396 - 2544 27-M 1060 - 1125 1543 - 1637 2545 - 2701 28-M 1126 - 1190 1638 - 1732 2702 - 2857 29-M 1191 - 1264 1733 - 1839 2858 - 3035 30-M 1265 - 1370 1840 - 1994 3036 - 3289 31-M 1371 - 1452 1995 - 2113 3290 - 3486 32-M 1453 - 1538 2114 - 2238 3487 - 3693 33-M 1539 - 1628 2239 - 2369 3694 - 3909 34-M 1629 - 1722 2370 - 2506 3910 - 4134 35-M 1723 - 1809 2507 - 2632 4135 - 4343 36-M 1810 - 1911 2633 - 2780 4344 - 4588 37-M 1912 - 1989 2781 - 2894 4589 - 4775 38-M 1990 - 2099 2895 - 3054 4776 - 5039 39-M 2100 - 2213 3055 - 3220 5040 - 5313 40-M 2214 - 2331 3221 - 3391 5314 - 5596 At least Q (quartile), ~25% error correction # Note that only quartile error correction is optimal beyond version 4.\nVersion-Error Correction Binary/Byte Alphanumeric Numeric 1-H 1 - 7 1 - 10 1 - 17 1-Q 8 - 11 11 - 16 18 - 27 2-H 12 - 14 17 - 20 28 - 34 2-Q 15 - 20 21 - 29 35 - 48 3-H 21 - 24 30 - 35 49 - 58 3-Q 25 - 32 36 - 47 59 - 77 4-H 33 - 34 48 - 50 78 - 82 4-Q 35 - 46 51 - 67 83 - 111 5-Q 47 - 60 68 - 87 112 - 144 6-Q 61 - 74 88 - 108 145 - 178 7-Q 75 - 86 109 - 125 179 - 207 8-Q 87 - 108 126 - 157 208 - 259 9-Q 109 - 130 158 - 189 260 - 312 10-Q 131 - 151 190 - 221 313 - 364 11-Q 152 - 177 222 - 259 365 - 427 12-Q 178 - 203 260 - 296 428 - 489 13-Q 204 - 241 297 - 352 490 - 580 14-Q 242 - 258 353 - 376 581 - 621 15-Q 259 - 292 377 - 426 622 - 703 16-Q 293 - 322 427 - 470 704 - 775 17-Q 323 - 364 471 - 531 776 - 876 18-Q 365 - 394 532 - 574 877 - 948 19-Q 395 - 442 575 - 644 949 - 1063 20-Q 443 - 482 645 - 702 1064 - 1159 21-Q 483 - 509 703 - 742 1160 - 1224 22-Q 510 - 565 743 - 823 1225 - 1358 23-Q 566 - 611 824 - 890 1359 - 1468 24-Q 612 - 661 891 - 963 1469 - 1588 25-Q 662 - 715 964 - 1041 1589 - 1718 26-Q 716 - 751 1042 - 1094 1719 - 1804 27-Q 752 - 805 1095 - 1172 1805 - 1933 28-Q 806 - 868 1173 - 1263 1934 - 2085 29-Q 869 - 908 1264 - 1322 2086 - 2181 30-Q 909 - 982 1323 - 1429 2182 - 2358 31-Q 983 - 1030 1430 - 1499 2359 - 2473 32-Q 1031 - 1112 1500 - 1618 2474 - 2670 33-Q 1113 - 1168 1619 - 1700 2671 - 2805 34-Q 1169 - 1228 1701 - 1787 2806 - 2949 35-Q 1229 - 1283 1788 - 1867 2950 - 3081 36-Q 1284 - 1351 1868 - 1966 3082 - 3244 37-Q 1352 - 1423 1967 - 2071 3245 - 3417 38-Q 1424 - 1499 2072 - 2181 3418 - 3599 39-Q 1500 - 1579 2182 - 2298 3600 - 3791 40-Q 1580 - 1663 2299 - 2420 3792 - 3993 Always H (high), ~30% error correction # Version-Error Correction Binary/Byte Alphanumeric Numeric 1-H 1 - 7 1 - 10 1 - 17 2-H 8 - 14 11 - 20 18 - 34 3-H 15 - 24 21 - 35 35 - 58 4-H 25 - 34 36 - 50 59 - 82 5-H 35 - 44 51 - 64 83 - 106 6-H 45 - 58 65 - 84 107 - 139 7-H 59 - 64 85 - 93 140 - 154 8-H 65 - 84 94 - 122 155 - 202 9-H 85 - 98 123 - 143 203 - 235 10-H 99 - 119 144 - 174 236 - 288 11-H 120 - 137 175 - 200 289 - 331 12-H 138 - 155 201 - 227 332 - 374 13-H 156 - 177 228 - 259 375 - 427 14-H 178 - 194 260 - 283 428 - 468 15-H 195 - 220 284 - 321 469 - 530 16-H 221 - 250 322 - 365 531 - 602 17-H 251 - 280 366 - 408 603 - 674 18-H 281 - 310 409 - 452 675 - 746 19-H 311 - 338 453 - 493 747 - 813 20-H 339 - 382 494 - 557 814 - 919 21-H 383 - 403 558 - 587 920 - 969 22-H 404 - 439 588 - 640 970 - 1056 23-H 440 - 461 641 - 672 1057 - 1108 24-H 462 - 511 673 - 744 1109 - 1228 25-H 512 - 535 745 - 779 1229 - 1286 26-H 536 - 593 780 - 864 1287 - 1425 27-H 594 - 625 865 - 910 1426 - 1501 28-H 626 - 658 911 - 958 1502 - 1581 29-H 659 - 698 959 - 1016 1582 - 1677 30-H 699 - 742 1017 - 1080 1678 - 1782 31-H 743 - 790 1081 - 1150 1783 - 1897 32-H 791 - 842 1151 - 1226 1898 - 2022 33-H 843 - 898 1227 - 1307 2023 - 2157 34-H 899 - 958 1308 - 1394 2158 - 2301 35-H 959 - 983 1395 - 1431 2302 - 2361 36-H 984 - 1051 1432 - 1530 2362 - 2524 37-H 1052 - 1093 1531 - 1591 2525 - 2625 38-H 1094 - 1139 1592 - 1658 2626 - 2735 39-H 1140 - 1219 1659 - 1774 2736 - 2927 40-H 1220 - 1273 1775 - 1852 2928 - 3057 ","date":"1 August 2023","permalink":"/extra/qr-character-limits/","section":"Extra","summary":"A reference for standard QR code data capacities in the common input modes.","title":"Complete Tables of QR Code Character Limits"},{"content":"","date":"1 August 2023","permalink":"/tags/programming/","section":"Tags","summary":"","title":"programming"},{"content":" The basic advice # If you just want to know how to make the smallest possible standard QR code for a website,\nUse uppercase and no more than 25 characters (0–9, A–Z, space, and $%*+-./:). If using non-alphanumeric characters, use no more than 17 characters. Include http:// or https:// at the start of your URL for compatibility with all QR readers. This effectively limits you to 18 alphanumeric characters or 10 non-alphanumeric characters. This will give you a 21x21 pixel (version 1) standard QR code.\nTwo QR codes for the same URL. Using uppercase takes 21x21 pixels (left) while lowercase takes 25x25 pixels (right). You can generate these on your own with these two Python commands.\nimport segno segno.make_qr(\u0026#34;HTTPS://RYANAGIBSON.COM\u0026#34;).show() segno.make_qr(\u0026#34;https://ryanagibson.com\u0026#34;).show() What about error correction? # When creating small QR codes, you may want to enforce specific error correction levels. Higher correction levels enable faster and easier scanning, but decrease the maximum number of characters that you can fit in a 21x21 QR code.\nFour levels are available, each offering different corruption tolerances and data storage capacities.\nError correction level L (Low) M (Medium) Q (Quartile) H (High) Data corruption allowed ~7% ~15% ~25% ~30% Error correction level Alphanumeric character limit Byte character limit L (Low) 25 17 M (Medium) 20 14 Q (Quartile) 16 11 H (High) 10 7 For example, the following QR codes are all for HTTPS://RYGI.ME with the maximum amount of data corruption shown.1 Despite this, they should still scan correctly.\nLeft to right: QR codes with low, medium, quartile, and high error correction. Top: codes with no corruptions. Bottom: the same codes with data sections shown in blue and mock corruptions shown in red. As usual, error correction also lets you add in artistic embellishments, even with the tiny size! This obviously affects the error correction\u0026rsquo;s effectiveness, but can make your QR code more eye-catching. Here are a few examples I played around with.\nEight QR codes that all point to the same website. They have been intentionally corrupted to make the design more interesting and unique while maintaining readability. In fact, with slight tweaks to the URL, you can artistically corrupt the QR code beyond the theoretical limits of error correction! This would be most useful if you set up redirects to the desired page, but short domains are often explicitly set up for redirection anyway.\nBelow are two examples where a 15x5 pattern is incorporated into the design. This region of 75 pixels is relatively massive considering that a version 1 QR code has a data capacity of only 136 bits. Indeed, the corrupted region is more than 150% the maximum amount this QR code can normally correct!\nLeft: QR code for HTTP://RYGI.ME/+. Right: QR code for HTTP://RYGI.ME/8. They have been very heavily corrupted for design purposes (shown in blue), but still scan correctly. Complete tables of QR code character limits # If you\u0026rsquo;re interested in a more comprehensive reference of the character limits for QR codes, please refer to \u0026ldquo;Complete Tables of QR Code Character Limits\u0026rdquo;.\nSee also and references # The segno Python package for generating standard QR codes and the significantly less supported (and seemingly proprietary) Micro QR codes. The smallest Micro QR code is 11x11 pixels, but could only hold enough data to store a URL (with the http:// prefix) in the 15x15 pixel variant. That one could hold up to HTTP://RYGI.ME. The largest Micro QR code is 17x17 pixels, which could hold up to HTTP://RYANGIBSON.DEV. Wikipedia\u0026rsquo;s QR Code article for a general overview of the standard, its design, features, etc. Denso Wave\u0026rsquo;s What is a QR Code? which discusses more advanced concepts and features of the code. One interesting feature is to split the data into multiple chunks, each with its own encoding, for even more optimal storage. The last one with high error correction drops the HTTPS://, so it will scan as text rather than a URL on some systems. For websites, version 1-H is essentially impossible since HTTP://R.G is already 10 characters and single-character TLDs do not currently exist.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"1 August 2023","permalink":"/posts/small-qr-codes/","section":"Posts","summary":"Some brief tips and discussion on how to make tiny QR codes with a focus on web URLs.","title":"Tips on Creating the Smallest Possible QR Codes"},{"content":"","date":"25 July 2023","permalink":"/tags/github/","section":"Tags","summary":"","title":"github"},{"content":"","date":"25 July 2023","permalink":"/tags/steganography/","section":"Tags","summary":"","title":"steganography"},{"content":" What is steganography? # In short, steganography is the art of concealing information within another, non-secret message, much like the use of invisible ink on a seemingly innocuous letter.1 The idea is that you could pass the message through many untrusted carriers, such as the internet, without arousing suspicion from most observers.\nAlice transfers a hidden message to Bob over the internet within a seemingly unremarkable image. In today\u0026rsquo;s digital age, you may be surprised as to how much data can be crammed into a file without changing it much at all. For example, below are three tiny 220x220 photos of a flower, but\nOne contains the entire, uncompressed text of the United States Constitution. Another contains the entire text of Shakespeare\u0026rsquo;s Macbeth, containing a little under 20k words. These tiny flowers look practically identical, but two of them hide thousands of words of information. Can you tell which is which? We\u0026rsquo;ll delve into how this is possible in How does (digital) steganography work?, but first let\u0026rsquo;s explore some real-world examples.\nReal-world examples of steganography # We\u0026rsquo;ll start with some physical, non-digital instances.\nThe EURion constellation # One of the simplest methods to hide data is to overlay a pattern in the hopes that it can be recovered later.\nFor example, many banknotes worldwide contain a precise arrangement of circles designed to allow printers and imaging software to combat counterfeiting operations. This has never been officially publicized, but is informally called the \u0026ldquo;EURion constellation\u0026rdquo; and has been integrated into at least ~60 countries\u0026rsquo; currencies.\nIf you happen to have a scanner and some cash on hand, you can try copying one of these banknotes. Depending on the model and brand of the scanner, it might refuse to copy or intentionally corrupt the print by adding stripes across the bill! The one that I own tends to forcibly stop the print halfway through.\nLeft: the specific pattern of circles in the EURion constellation. Middle: A portion of the back of an American $20 bill. Right: Same as the middle, but with the various constellations highlighted in green. Several other examples of the EURion constellation on British, German, and Euro banknotes. Some are more creative with their inclusion into the design than others. Printer \u0026ldquo;Machine Identification Codes\u0026rdquo; # In another covert application of steganography, many color printers use tiny yellow dots that are invisible to the naked eye to overlay a tracking watermark. These encode the serial number of the printer and some date and time information across every printed page.\nThis is also rumored to be one of the reasons why some printers refuse to print black-and-white documents when they are running low on color ink.\nThe existence of this technology remained unknown to the public for around two decades as it was developed under secret agreements with various national governments to enhance their forensic tracing capabilities. As a result, it\u0026rsquo;s been used to track down counterfeiters and whistleblowers across the world.\nAn image of text printed from a Laserjet printer. Blue light makes the Machine Identification Code visible, consisting of scattered yellow dots that are ~0.1mm wide. Steganography in video games # Game developers also use steganography to identify the author of screenshots or gameplay videos, especially when they include cheating, abuse, or unauthorized use of private servers.\nIn the 2000s, Blizzard implemented very faint watermarks on screenshots of World of Warcraft which contained repeating patterns of dots across the entire screen. These patterns, developed by Digimarc, encoded various details of the user\u0026rsquo;s account and the server that they were logged into. Like the other examples above, this screenshot tagging remained entirely secret for the first few years of its existence.\nTwo examples of the watermarks used in World of Warcraft, heavily post-processed to reveal the hidden pattern. Similarly, Microsoft encoded hardware information in the user interface of the Xbox 360\u0026rsquo;s early builds. Each console\u0026rsquo;s animations were unique, which allowed the company to crack down on potential leakers. At the time, the employees were under NDAs and would be subject to civil penalties for disclosing nonpublic information about the console\u0026rsquo;s development.\nHow does (digital) steganography work? # In the realm of digital steganography, there are many different techniques, but one of the simplest is \u0026ldquo;Least Significant Bit\u0026rdquo; (LSB) steganography.\nBasically, the method takes advantage of the fact that most data formats encode information in binary numbers, and the least significant bits of these have the smallest impact on the overall value. By replacing these unimportant bits with a secondary message, we can hide data without making any apparent changes to the file\u0026rsquo;s original appearance or meaning.\nFor example, a common image encoding is to store how much red, green, and blue (RGB) is in each pixel with one byte for each color. These values range from 0 to 255 and we can usually change them slightly without most people noticing. Human senses are just far too imprecise to tell the difference, especially when you\u0026rsquo;re not looking for it!\nAn example of how we can replace the LSBs of an image\u0026rsquo;s pixels to encode a hidden message. The resulting change is nigh-impossible to visually detect. However, this hidden data can be easily exposed in a \u0026ldquo;visual attack\u0026rdquo; where we inspect the LSBs of the image. For instance, if we perform this attack on the three flowers shown at the start of this post, the differences become obvious.\nTop: the three flower images from the start of this blog post. Bottom: a visualization of the least significant bits of each image. The original image is on the right, and you can faintly see the flower\u0026rsquo;s outline in its LSBs. In contrast,\nThe one on the left appears completely random2 since it contained the contents of Hamlet. The one in the middle contained the uncompressed text of the U.S. Constitution and you can visually confirm that the data only takes up the first ~3/4 of the image. In general, steganographic techniques and their adversarial \u0026ldquo;steganalysis\u0026rdquo; counterparts are constantly evolving. More advanced algorithms than this one will minimize changes to the original image\u0026rsquo;s statistics and would only be detectable with much more sophisticated methods.\nOn the other hand, this simple technique lets us store a considerable amount of data! This is a direct consequence of the use of binary encoding since the last bit in each byte can only change the color by 1/255 (~0.4%) despite taking up 1/8th (12.5%) of the data itself.\nIndeed, in the flower images above we\u0026rsquo;ve replaced a whole 25% of the actual image data but only altered around 1% of the color information. There is a significant trade-off between the amount of hidden data and the impact on the visual quality of the image.3\nA demonstration of the trade-off between the number of LSBs used to hide data in an image and the corresponding loss of the original color information. More creative steganography techniques # While we\u0026rsquo;ve provided a reasonable introduction to the basic ideas, there is an abundance of more interesting methods, so we\u0026rsquo;ll briefly mention some of them here.\nText steganography: Messages can be hidden within the formatting, whitespace, or invisible characters of a text itself. Some more intriguing techniques use specific sentence structures or grammatical constructs to impart information. Think of the stereotypical scenario in which you suspect something is amiss when a friend texts you in a particularly unusual writing style. Spread Spectrum: These techniques spread hidden data over a wide range of frequencies, but at a lower amplitude, effectively concealing the covert message beneath the natural noise of the transmission medium. Similar variants are also applicable to images and videos. Audio steganography: In addition to the usual binary techniques, fine manipulation of echoes, harmonics, or the underlying frequency bands can be used to store information. Networking steganography: Many protocols can be manipulated to convey information through calculated usage of (perhaps nonstandard) features, slight manipulation of timing delays between packets, or intentional corruptions that would appear to be typical transmission errors. EOF steganography: End of file markers or headers can be manipulated to hide data outside the intended scope of a file. While not strictly steganography in the traditional sense, it has been repeatedly used in malware and hacking operations, so it is worth mentioning.4 If these topics sound interesting to you, I highly recommend searching the internet and exploring any new techniques that come to mind!\nSee also and references # My Python package, stego-lsb, which I used to generate the steganographed images in this post. It also supports sounds files and arbitrary sequences of binary data. A forum post containing details of the steganographic methods used in World of Warcraft. A Hacker News thread discussing the tracking methods used in Xbox 360 NDA beta builds. A Computerphile video on steganographic techniques in images, which includes a discussion of a method for JPEG images that is robust to simple visual attacks. More generally, consider the following Wikipedia articles.\nSteganography EURion constellation Machine Identification Code Coded anti-piracy, which is a pattern of dots used by the film industry since the 1980s to trace the origins of pirated copies. Deniable encryption techniques, where it is generally impossible to prove that any information is encrypted at all. In fact, steganography comes from Greek word \u0026ldquo;steganographia\u0026rdquo;, which literally means something akin to \u0026ldquo;hidden writing\u0026rdquo;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nObviously, it\u0026rsquo;s not actually random since this is just compressed English text. In practice, the hidden data should probably be encrypted in some way that increases the apparent randomness. Otherwise, steganography simply becomes an exercise in security through obscurity.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIf the transmission channel is noisy, a certain amount of error correction would also need to be included, which will necessarily decrease the amount of data available for use. This includes electrical interference on the wire, image compression, audio being played through physical loudspeakers rather than in a perfect digital medium, etc.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThis is sometimes referred to as stegomalware.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"25 July 2023","permalink":"/posts/steganography-intro/","section":"Posts","summary":"A general introduction to hiding information in plain sight, its uses in the real-world, and how it works in digital mediums.","title":"Steganography: Hiding Data Inside Data"},{"content":"I considered several domain names before settling on the current one for this website, which are listed here. Indeed, all the following domains should redirect to this site until at least mid-2024 when they come up for renewal.\nVariations of my name # These are fairly straightforward and simply incorporate my name in obvious ways.\nhttps://ryanagibson.com/ https://ryanalexandergibson.com/ https://ryanalexgibson.com/ https://ryangibson.dev/ More creative variations # These are a bit more creative and fun, but they may have limited use in professional circles.\nhttps://ragibs.com/ https://rgibson.dev/ https://ryalgi.com/ This one is a short domain for convenience or perhaps when space is extremely limited.\nhttps://rygi.me/ Based on my GitHub username # https://ragibson.dev/ https://ragibson.net/ https://ragibson.org/ ","date":"8 July 2023","permalink":"/posts/alternate-domain-names/","section":"Posts","summary":"I considered several domain names before settling on the current one for this website, which are listed here.","title":"Alternate Domain Names"},{"content":"","date":"8 July 2023","permalink":"/tags/domains/","section":"Tags","summary":"","title":"domains"},{"content":"","date":"8 July 2023","permalink":"/tags/about/","section":"Tags","summary":"","title":"about"},{"content":" Hi! I\u0026rsquo;m Ryan # I am currently working as a Quantitative Analyst at Wells Fargo, primarily focusing on risk model research, development, maintenance, and monitoring. In much of my free time, I work on mathematical, statistical, and programming hobby projects.\nFeel free to reach out with any questions, comments, or ideas and I\u0026rsquo;ll try to respond reasonably quickly!\nSome of my interests # In university, my education was in Pure Mathematics and Computer Science with research interests including\n🕸️ Network Science 🚅 High Performance Computing 🔐 Cybersecurity 💽 Operating Systems 🔋 Microarchitecture More recently, I\u0026rsquo;ve been additionally working on\n🤖 Machine Learning 🧮 Numerical Analysis Some projects on GitHub # Feel free to look through my repositories list on GitHub (many are private), but I\u0026rsquo;ve linked some projects in the images below!\n","date":"8 July 2023","permalink":"/about/","section":"Ryan A. Gibson","summary":"A brief introduction to my hobbies, interests, work, etc.","title":"About me"}]